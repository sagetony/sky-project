import { subscribeKey as subKey } from 'valtio/vanilla/utils';
import { proxy, ref } from 'valtio/vanilla';
import { CoreHelperUtil } from '../utils/CoreHelperUtil.js';
import { StorageUtil } from '../utils/StorageUtil.js';
import { TransactionsController } from './TransactionsController.js';
import { ChainController } from './ChainController.js';
import {} from '@reown/appkit-wallet';
import { ModalController } from './ModalController.js';
import { ConnectorController } from './ConnectorController.js';
import { EventsController } from './EventsController.js';
import { OptionsController } from './OptionsController.js';
// -- State --------------------------------------------- //
const state = proxy({
    wcError: false,
    buffering: false,
    status: 'disconnected'
});
// eslint-disable-next-line init-declarations
let wcConnectionPromise;
// -- Controller ---------------------------------------- //
export const ConnectionController = {
    state,
    subscribeKey(key, callback) {
        return subKey(state, key, callback);
    },
    _getClient() {
        return state._client;
    },
    setClient(client) {
        state._client = ref(client);
    },
    async connectWalletConnect() {
        StorageUtil.setConnectedConnector('WALLET_CONNECT');
        if (CoreHelperUtil.isTelegram()) {
            if (wcConnectionPromise) {
                try {
                    await wcConnectionPromise;
                }
                catch (error) {
                    /* Empty */
                }
                wcConnectionPromise = undefined;
                return;
            }
            if (!CoreHelperUtil.isPairingExpired(state?.wcPairingExpiry)) {
                const link = state.wcUri;
                state.wcUri = link;
                return;
            }
            wcConnectionPromise = new Promise(async (resolve, reject) => {
                await this._getClient()
                    ?.connectWalletConnect?.(uri => {
                    state.wcUri = uri;
                    state.wcPairingExpiry = CoreHelperUtil.getPairingExpiry();
                })
                    .catch(reject);
                resolve();
            });
            this.state.status = 'connecting';
            await wcConnectionPromise;
            wcConnectionPromise = undefined;
            state.wcPairingExpiry = undefined;
            this.state.status = 'connected';
        }
        else {
            await this._getClient()?.connectWalletConnect?.(uri => {
                state.wcUri = uri;
                state.wcPairingExpiry = CoreHelperUtil.getPairingExpiry();
            });
        }
    },
    async connectExternal(options, chain, setChain = true) {
        await this._getClient()?.connectExternal?.(options);
        if (setChain) {
            ChainController.setActiveNamespace(chain);
        }
    },
    async reconnectExternal(options) {
        await this._getClient()?.reconnectExternal?.(options);
        StorageUtil.setConnectedConnector(options.type === 'AUTH' ? 'ID_AUTH' : options.type);
    },
    async setPreferredAccountType(accountType) {
        ModalController.setLoading(true);
        const authConnector = ConnectorController.getAuthConnector();
        if (!authConnector) {
            return;
        }
        await authConnector?.provider.setPreferredAccount(accountType);
        await this.reconnectExternal(authConnector);
        ModalController.setLoading(false);
        EventsController.sendEvent({
            type: 'track',
            event: 'SET_PREFERRED_ACCOUNT_TYPE',
            properties: {
                accountType,
                network: ChainController.state.activeCaipNetwork?.caipNetworkId || ''
            }
        });
    },
    async signMessage(message) {
        return this._getClient()?.signMessage(message);
    },
    parseUnits(value, decimals) {
        return this._getClient()?.parseUnits(value, decimals);
    },
    formatUnits(value, decimals) {
        return this._getClient()?.formatUnits(value, decimals);
    },
    async sendTransaction(args) {
        return this._getClient()?.sendTransaction(args);
    },
    async getCapabilities(params) {
        return this._getClient()?.getCapabilities(params);
    },
    async grantPermissions(params) {
        return this._getClient()?.grantPermissions(params);
    },
    async estimateGas(args) {
        return this._getClient()?.estimateGas(args);
    },
    async writeContract(args) {
        return this._getClient()?.writeContract(args);
    },
    async getEnsAddress(value) {
        return this._getClient()?.getEnsAddress(value);
    },
    async getEnsAvatar(value) {
        return this._getClient()?.getEnsAvatar(value);
    },
    checkInstalled(ids) {
        return this._getClient()?.checkInstalled?.(ids) || false;
    },
    resetWcConnection() {
        state.wcUri = undefined;
        state.wcPairingExpiry = undefined;
        state.wcLinking = undefined;
        state.recentWallet = undefined;
        state.status = 'disconnected';
        TransactionsController.resetTransactions();
        StorageUtil.deleteWalletConnectDeepLink();
    },
    setWcLinking(wcLinking) {
        state.wcLinking = wcLinking;
    },
    setWcError(wcError) {
        state.wcError = wcError;
        state.buffering = false;
    },
    setRecentWallet(wallet) {
        state.recentWallet = wallet;
    },
    setBuffering(buffering) {
        state.buffering = buffering;
    },
    setStatus(status) {
        state.status = status;
    },
    async disconnect() {
        try {
            const connectionControllerClient = this._getClient();
            const siwx = OptionsController.state.siwx;
            if (siwx) {
                const activeCaipNetwork = ChainController.getActiveCaipNetwork();
                const address = CoreHelperUtil.getPlainAddress(ChainController.getActiveCaipAddress());
                if (activeCaipNetwork && address) {
                    await siwx.revokeSession(activeCaipNetwork.caipNetworkId, address);
                }
            }
            await connectionControllerClient?.disconnect();
            this.resetWcConnection();
        }
        catch (error) {
            throw new Error('Failed to disconnect');
        }
    }
};
//# sourceMappingURL=ConnectionController.js.map